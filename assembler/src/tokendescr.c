#include <esc64asm/tokendescr.h>

#include <stdlib.h>
#include <assert.h>

const static InstructionDescr INSTR_DESCR_ADD =
{
	.opcode = OPCODE_ADD,
	.isWide = 0,
	.argList = ARGLIST3(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_ADC =
{
	.opcode = OPCODE_ADC,
	.isWide = 0,
	.argList = ARGLIST3(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_SUB =
{
	.opcode = OPCODE_SUB,
	.isWide = 0,
	.argList = ARGLIST3(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};

const static InstructionDescr INSTR_DESCR_INC =
{
	.opcode = OPCODE_INC,
	.isWide = 0,
	.argList = ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_DEC =
{
	.opcode = OPCODE_DEC,
	.isWide = 0,
	.argList = ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};

const static InstructionDescr INSTR_DESCR_OR =
{
	.opcode = OPCODE_OR,
	.isWide = 0,
	.argList = ARGLIST3(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_XOR =
{
	.opcode = OPCODE_XOR,
	.isWide = 0,
	.argList = ARGLIST3(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_AND =
{
	.opcode = OPCODE_AND,
	.isWide = 0,
	.argList = ARGLIST3(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_SHL =
{
	.opcode = OPCODE_SHL,
	.isWide = 0,
	.argList = ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_SHR =
{
	.opcode = OPCODE_SHR,
		.isWide = 0,
		.argList = ARGLIST2(
			ARG(ARG_TYPE_REG, OP0),
			ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_MOV_WIDE =
{
	.opcode = OPCODE_MOV_WIDE,
	.isWide = 1,
	.argList = ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_IMM, OP3))
};
const static InstructionDescr INSTR_DESCR_MOV =
{
	.opcode = OPCODE_MOV,
	.isWide = 0,
	.argList = ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_MOV_EQ =
{
	.opcode = OPCODE_MOV_EQ,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_MOV_NEQ =
{
	.opcode = OPCODE_MOV_NEQ,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_MOV_LESS =
{
	.opcode = OPCODE_MOV_LESS,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_MOV_LESS_EQ =
{
	.opcode = OPCODE_MOV_LESS_EQ,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_CMP =
{
	.opcode = OPCODE_CMP,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_LDR =
{
	.opcode = OPCODE_LDR,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_STR =
{
	.opcode = OPCODE_STR,
	.isWide = 0,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP1),
		ARG(ARG_TYPE_REG, OP2))
};
const static InstructionDescr INSTR_DESCR_CALL =
{
	.opcode = OPCODE_CALL,
	.isWide = 0,
	.argList = 	ARGLIST1(
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_PUSH =
{
	.opcode = OPCODE_PUSH,
	.isWide = 0,
	.argList = 	ARGLIST1(
		ARG(ARG_TYPE_REG, OP1))
};
const static InstructionDescr INSTR_DESCR_POP =
{
	.opcode = OPCODE_POP,
	.isWide = 0,
	.argList = 	ARGLIST1(
		ARG(ARG_TYPE_REG, OP0))
};

//FIXME quickfix, these are temporary opcode definitions. eventualy they will be aliases for mov pseudo-opcodes
const static InstructionDescr INSTR_DESCR_JZ =
{
	.opcode = OPCODE_JZ,
	.isWide = 1,
	.argList = 	ARGLIST2(
		ARG(ARG_TYPE_REG, OP0),
		ARG(ARG_TYPE_IMM, OP3))
};
const static InstructionDescr INSTR_DESCR_JNZ =
{
	.opcode = OPCODE_JNZ,
	.isWide = 1,
	.argList = 	ARGLIST2(
			ARG(ARG_TYPE_REG, OP0),
			ARG(ARG_TYPE_IMM, OP3))
};
const static InstructionDescr INSTR_DESCR_JC =
{
	.opcode = OPCODE_JC,
	.isWide = 1,
	.argList = 	ARGLIST2(
			ARG(ARG_TYPE_REG, OP0),
			ARG(ARG_TYPE_IMM, OP3))
};
const static InstructionDescr INSTR_DESCR_JNC =
{
	.opcode = OPCODE_JNC,
	.isWide = 1,
	.argList = 	ARGLIST2(
			ARG(ARG_TYPE_REG, OP0),
			ARG(ARG_TYPE_IMM, OP3))
};
//end quickfix

static const TokenDescr tokenDescrTable[TOKEN_DESCR_TABLE_SIZE] =
{
		[TOKEN_DESCR_LABEL_DECL]			= { "ldecl", TOKEN_CLASS_LABEL_DECL, TOKEN_VALUE_TYPE_STRING, NULL },
		[TOKEN_DESCR_NUMBER]				= { "number", TOKEN_CLASS_VALUE, TOKEN_VALUE_TYPE_NUMBER, NULL },
		[TOKEN_DESCR_STRING]				= { "string", TOKEN_CLASS_VALUE, TOKEN_VALUE_TYPE_STRING, NULL },
		[TOKEN_DESCR_LABEL_REF]				= { "lref", TOKEN_CLASS_VALUE, TOKEN_VALUE_TYPE_STRING, NULL },
		[TOKEN_DESCR_REGISTER_REF]			= { "reg", TOKEN_CLASS_VALUE, TOKEN_VALUE_TYPE_NUMBER, NULL },
		[TOKEN_DESCR_OPCODE_ADD]			= { "ADD", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_ADD },
		[TOKEN_DESCR_OPCODE_ADC]			= { "ADC", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_ADC },
		[TOKEN_DESCR_OPCODE_SUB]			= { "SUB", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_SUB },
		[TOKEN_DESCR_OPCODE_INC]			= { "INC", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_INC },
		[TOKEN_DESCR_OPCODE_DEC]			= { "DEC", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_DEC },
		[TOKEN_DESCR_OPCODE_OR]				= { "OR", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_OR },
		[TOKEN_DESCR_OPCODE_XOR]			= { "XOR", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_XOR },
		[TOKEN_DESCR_OPCODE_AND]			= { "AND", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_AND },
		[TOKEN_DESCR_OPCODE_SHL]			= { "SHL", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_SHL },
		[TOKEN_DESCR_OPCODE_SHR]			= { "SHR", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_SHR },
		[TOKEN_DESCR_PSEUDO_OPCODE_MOV]		= { "MOV?", TOKEN_CLASS_PSEUDO_OPCODE, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_OPCODE_MOV]			= { "MOV", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_MOV },
		[TOKEN_DESCR_OPCODE_MOV_WIDE]		= { "MOV", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_MOV_WIDE },
		[TOKEN_DESCR_OPCODE_MOV_EQ]			= { "MOV_EQ", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_MOV_EQ },
		[TOKEN_DESCR_OPCODE_MOV_NEQ]		= { "MOV_NEQ", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_MOV_NEQ },
		[TOKEN_DESCR_OPCODE_MOV_LESS]		= { "MOV_LESS", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_MOV_LESS },
		[TOKEN_DESCR_OPCODE_MOV_LESS_EQ]	= { "MOV_LESS_EQ", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_MOV_LESS_EQ },
		[TOKEN_DESCR_OPCODE_CMP]			= { "CMP", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_CMP },
		[TOKEN_DESCR_OPCODE_LDR]			= { "LDR", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_LDR },
		[TOKEN_DESCR_OPCODE_STR]			= { "STR", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_STR },
		[TOKEN_DESCR_OPCODE_CALL]			= { "CALL", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_CALL },
		[TOKEN_DESCR_OPCODE_PUSH]			= { "PUSH", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_PUSH },
		[TOKEN_DESCR_OPCODE_POP]			= { "POP", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_POP },
		//FIXME quickfix, these are temporary opcode definitions. eventualy they will be aliases for mov pseudo-opcodes
		[TOKEN_DESCR_OPCODE_JZ]				= { "JZ", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_JZ },
		[TOKEN_DESCR_OPCODE_JNZ]			= { "JNZ", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_JNZ },
		[TOKEN_DESCR_OPCODE_JC]				= { "JC", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_JC },
		[TOKEN_DESCR_OPCODE_JNC]			= { "JNC", TOKEN_CLASS_OPCODE, TOKEN_VALUE_TYPE_NONE, &INSTR_DESCR_JNC },
		//end quickfix
		[TOKEN_DESCR_DIR_WORD]				= { "WORD", TOKEN_CLASS_DIRECTIVE, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_DIR_ASCII]				= { "ASCII", TOKEN_CLASS_DIRECTIVE, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_DIR_GLOBAL]			= { "GLOBAL", TOKEN_CLASS_DIRECTIVE, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_DIR_SECTION]			= { "SECTION", TOKEN_CLASS_DIRECTIVE, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_COMMA]					= { ",", TOKEN_CLASS_PUNCTUATION, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_EOL]					= { "EOL", TOKEN_CLASS_PUNCTUATION, TOKEN_VALUE_TYPE_NONE, NULL },
		[TOKEN_DESCR_EOF]					= { "EOF", TOKEN_CLASS_PUNCTUATION, TOKEN_VALUE_TYPE_NONE, NULL }
};

const TokenDescr* GetTokenDescr(TokenDescrId id)
{
	assert(id < TOKEN_DESCR_TABLE_SIZE);
	return &tokenDescrTable[id];
}
